#!/usr/bin/python
#Parsing PDF Objects
#decompress Flatedecode
#Added checks for Some malicious feature
#handle Obj ref
#Populate PDF feature dictionary




import sys,struct
import re,os
#from tokenize import tokenize_buffer
from nltk.tokenize import RegexpTokenizer
from cStringIO import StringIO
from zlib import decompress
from collections import defaultdict
from optparse import OptionParser
import binascii
import score_pdf
from ascii85 import ascii85decode,asciihexdecode
from lzw  import lzwdecode
#from adobeapp import Scan_JS 

debug  = True   
global Stats
Stats = 0  

def get_words(w):
   
    for i in w: 
        if len(i) > 5:
           return i 



def debug(data):
    # #print data
    sys.exit(0)

def tokenize_buffer(buff):
    long_word_freq ={}  
    tokenizer = RegexpTokenizer('\w+|\$[\d\.]+|\S+\W+')
    tokens =  tokenizer.tokenize(buff)
    chars = re.findall('\+|@|\[|\\|\(|\,',buff)
    if chars: chars =[ch  for  ch in chars if ch]
    words  = (re.split('\W',w) for w in tokens if len(w) > 5)
    long_words =  map(get_words,words)        
    for word in long_words:
             try:
                 long_word_freq[word] += 1
             except:
                 long_word_freq.setdefault(word,0)
    return long_word_freq, len(tokens),len(chars)







class PDFobjects():
     """
     Main PDF object Class 

     """  

     def __init__(self,pdf):
         self.objdata  =   {} 
         self.objects  =   {}  #object dictonary container for all PDF objects       
         self.objStats =   defaultdict(dict)  #  object Container Holding Information about object 
         self.temp     =   {}
         self.objbuff  = []
         self.dupobjects = False
         self.data  = pdf
         self.staticScript = '' #for those things not within objects append to this structure
         #special children types
         self.isJS = False #could be a reference (or self contains JS)
         self.isDelayJS  = False #for OpenAction
         self.isEmbedded = False #for /EmbeddedFile
         self.isStream = False
         self.isJSFound  = False
         self.JsObjcount  = 0 
         self.isAnnot = False
         self.isObjStm = []
         self.isMulti_compress = False
         self.dup      = False
         self.dup_count = 0
         self.isXFA = False
         self.isEncrypt = False
         self.isFromObjStream = False
         self.knownName = '' #related to annots
         self.subj = '' #related to annots
         self.obj_ref = False
         self.ref_count = 0 
         self.ref_depth = 0 
         self.xfaChildren = []
         self.stats = 0
     

     def handle_evasion(self,key,data):
         """
         Check for any evasion method
         """
              
         self.key = key 
         self.buff = data
         
         self.count = 0 
         chars = re.findall("#[4-7]\w",self.buff,re.IGNORECASE|re.MULTILINE) 
        
         self.html_chars = sum([(self.count + 1) for ch in chars if ch ])
         if self.html_chars >= 2:
            self.objStats[self.key]['html_evasion'] = True
            self.objStats[self.key]['html_count']   = self.html_chars 
         
         return True
     
     def _get_freq_analyses(self,Stream):
         """
         experimental feature to 
         detect repetitive chars  
         """   
         char_freq = {}
         #print Stream 
         self.chars =  map(ord,Stream)
         total_chars = len(self.chars) 
         for ch in self.chars:
                 try:
                   char_freq[ch] += 1
                   #if char_req[ch] > 1000
                 except:
                   char_freq.setdefault(ch,0)
         char_freq = dict((ch,float(char_freq[ch])/float(total_chars)) for ch in char_freq)   
         #print char_freq
         for key,val in  char_freq.items(): 
                if val > 0.2:
                    return True      
         return False 
                
                          
     def get_Stream_Info(self,Stream):
        """
        detect suspicious Streams.    

        """
        # #print Stream
        try: 
          

          
          self.Stream =  map(ord,Stream)
          count = 0
          char_freq = {} 
          ## check for special char frequency in stream
          special_chars = [i  for i in self.Stream  if (i >= 33 and i <= 47) or (i >= 58 and i <= 64) or (i >= 91 and i <= 96)]
          for ch in special_chars: 
                 try:   
                   char_freq[ch] += 1 
                 except:
                   char_freq.setdefault(ch,0)
      

          # #print char_freq
        except:
           #print Stream
          sys.exit(0)   


     def _isJS_inStream(self,key):
         self.key = key  
         self.stream = self.objects[self.key]
         if re.search('stream',self.stream[:100]):
            return True
         return False
              
     def _is_File(self,key):
         self.key = key
         self.stream = self.objects[self.key]
         if re.search('CWS|%PDF',self.stream):
            return True
         return False 
     def decompress_stream(self,key):
         """
         Decompress  compressed object Streams. 
         """ 
         self.key = key 
         #print "++++++++++++ decompressing stream +++++++++++++++++++++++++" ,key
         try: 
          data  = self.objects[self.key]
          start = data.find("stream")
          end   = data.find("endstream")
          self.buff = data[start+6:].strip()
          if  len(self.buff) < 2:return
 
          self.methods = self.get_compMethod(key,data)
          self.data = self.buff.strip()  
          for self.method in self.methods:
              #print self.method
              if  'fl' == self.method.lower():
                  self.data =  decompress(self.data)
              if  'ascii85decode'  == self.method.lower():
                  self.data =  ascii85decode(self.data)
              if  'asciihexdecode' == self.method.lower():   
                  self.data =  asciihexdecode(self.data)
              if  'lzwdecode'      == self.method.lower():
                  self.data = lzwdecode(self.data)                                                             
                 
          if len(self.methods) == 0:        
             self.handle_evasion(key,data[:start])          
             
         except Exception,err:
               pass  
               #print sys.stderr.write('ERROR: %s\n' % str(err)),key,self.methods
         y = ""
         #print filter(lambda x: chr(ord(x)),self.data)
         return self.data
          
     def get_compMethod(self,key,data):
         self.stream = data
         self.key    = key    
         self.method = re.findall("(FL|ASCII85Decode|ASCIIHexDecode|JBIG2Decode|/A85|/AHx|LZWDecode)",self.stream[:100],re.IGNORECASE|re.MULTILINE)
         
         if len(self.method) > 0: 
                     self.objStats[self.key]['Multiple_Filters'] = True  

        
         return self.method

 
     def pdf_objs(self):
         #self.buff = self.data
         self._Objs= re.finditer('\d+[\s+\n+]\d+\sobj|\d+%[\s+\n+]\d+\s+obj',self.data,re.MULTILINE|re.IGNORECASE)
         self.objs = {}
          
         for obj in self._Objs:
             key =  obj.group()
             if key in self.objs:
                    key = key + "-dup" 
                    self.dup_count += 1
             self.objs[key] = obj.span()
         for self.obj in   self.objs:
          try:   
             if self.obj in self.objects:
                self.dup  = self.obj.split(' ')[0] + '-dup' 
                self.data_dup = self.data.replace(self.obj,self.dup,1) 
                self.start = self.objs[self.obj][1]
                self.obj = self.dup
                self.dup_count += 1
                if self.dup == False: self.dup = True
             else:
                self.start =  self.objs[self.obj][1]            
                self.buff  =  self.data[self.start:]
                self.end   =  self.buff.find('endobj')
                self.objects[self.obj] =  self.buff[0:self.end]
          except Exception, err:
             sys.stderr.write('ERROR: %s\n' % str(err)) 
         
         ## #print self.objects
         #sys.exit(0)
         return self.objects
     

     def _pdf_objs(self):
         #self.buff = self.data
         self._Objs= re.finditer('\d+[\s+\n+]\d+\sobj|\d+%[\s+\n+]\d+\s+obj',self.data,re.MULTILINE|re.IGNORECASE)
         self.objs = {}
         print  self._Objs 
         for obj in self._Objs:
             key =  obj.group() 
             self.objs[key] = obj.span()
         # if not self._Objs:  #print "buff not complete"
         if len(self.objs) == 0:
            return self.objs,1
         for self.obj in   self.objs:
          try:   
                self.start =  self.objs[self.obj][1]            
                self.buff  =  self.data[self.start:]
                self.end   =  self.buff.find('endobj')
 
                if  self.end < 0:
                    return self.objects,int(self.start)
                else: self.objects[self.obj] =  self.buff[0:self.end]

          except Exception, err:
             sys.stderr.write('ERROR: %s\n' % str(err)) 
         
                        
         return self.objects,0
 
 

     def __handle_redir(self,key):

         self.key = key
         self.obj = self.objects[key]
         self.ref_objs = None
         self.ref_objs = re.findall("\d+\s{0,5}\d\s{0,5}R",self.obj)
         for obj in self.ref_objs:
             self.ref_obj = re.split( '\s|\t',obj)
             for key in  self.objects:
                 self.obj =   re.split( '\s|\t|\n',key)
                 if (self.ref_obj[0] == self.obj[0]) and (self.ref_obj[1] == self.obj[1]):
                     self.objStats[self.key]['obj_ref'] = 'True'
                     self.objStats[self.key][obj] = key
         return True 




     def get_Javascript(self,key):
         self.key  = key 
         self.objbuff = self.objects[key]
         if re.search('/JS|Javascript',self.objbuff,re.IGNORECASE):
            self.objStats[key]['Type'].append('JS')
            self.objStats[key]['isJS'] = True
            if len(self.objbuff) > 300:
                # #print "large javascript code\n"
                self.objStats[key]['isJslarge'] = True  
                if self.get_jsStat(key): 
                        self.objStats[key]['JScript'] = True
                          
                        
            else:
               return False    
 
         else:
             return False
             ## #print "Handling redirection for",key
             #self.handle_redir(key,str(self.objbuff)) 
         return True




     def get_jsStat(self,key=None,Data=None):
         if key:self.jsStream = self.objects[key]
         if Data: self.jsStream = Data
         self.jsSize = len(self.jsStream)
         ## To Do: improvements and algo to detect Suspicious JS. 
         self.jsStream = re.sub("\x00|\+|'|\"",'',self.jsStream)
         self.jsObjects = re.findall('var=|var\s+=|unescape\(|unescape\s+\(|for\s+\(|for\(|while\s+\(|while\(|Array\s+\(|Array\(|\\.length|charAt|eval\(|\.getAnnots|\.replace|\.subject',self.jsStream)
         obj_count = 0
         js_keywords = []
         if self.jsObjects:
            for obj in self.jsObjects: 
              if obj:
                 obj_count += 1
                 if   obj.find("unescape"):
                      js_keywords.append("unescape")
                 elif obj.find("eval"):     
                      js_keywords.append("eval") 
         ### check for eval or unscape
         #print  self.jsObjects 
         if obj_count > 5:
               self.objStats[key]['Suspicious_Js'] = True
               self.objStats[key]['Jscript_objects'] = obj_count
               long_words,tokens,chars = tokenize_buffer(self.jsStream)
                #print len(long_words),tokens,chars
               self.objStats[key]['Jscript_code'] = self.jsStream

               return True
            
         elif obj_count == 0 and len(self.jsStream) > 100:
                if 'JS' in self.objStats[key]['Type']:
                    off = self.jsStream.find('JS')
                    self.objStats[key]['Jscript_code'] =  self.jsStream[100:500]
                    self.objStats[key]['isObfuscated'] = True
                    self.objStats[key]['Jscript_objects'] = obj_count 
                    # #print "Suspicous JS May be obfuscated or Compressed",key
                    return False
                else:
                    words,tokens,chars = tokenize_buffer(self.jsStream)
                    if chars > 30: self.objStats[key]['isObfuscated'] = True 
          
         elif obj_count <= 5: #and len(js_keywords):
               words,tokens,chars = tokenize_buffer(self.jsStream)
               for w in words:
                   if  words[w] > 10:
                        #self.objStats[key][w] = words[w]
                        self.objStats[key]['isObfuscated'] = True     
               if chars > 30: self.objStats[key]['isObfuscated'] = True   
               if len(js_keywords) > 0:
                  self.objStats[key]['Jscript_objects'] = obj_count   
                  self.objStats[key]['Suspicious_Js'] = True         
                  self.objStats[key]['Jscript_code'] =  self.jsStream[100:500] 
              
         else:
               long_words,tokens,chars = tokenize_buffer(self.jsStream)
               return False     
         self.objStats[key]['Jscript_objects'] = obj_count
  
     def parse_objs(self):  
 
         for key in self.objects:
            #self.objbuff = self.objects[key]
            objdata = self.objects[key]
            start = objdata.find('<<')
            end = objdata.rfind('>>') + 2
            self.objbuff = objdata[start:end]
            self.objdata[key] = self.objbuff
            #self.temp[key] = {}
            self.objStats[key]
            # Search for ALL intersting Tag Value's

            self.tags =  re.findall('/OpenAction|/Action|/Annot|/XFA|/Filter|/AcroForm|/JS|/EmbeddedFile|/Page',self.objbuff,re.IGNORECASE|re.MULTILINE)
            self.objStats[key]['Type'] = []
           
            if len(self.tags) > 0:
               ##  Main Loop handling ALL pdf  Objects and Tags  
               for i in xrange(0,len(self.tags)):

                   
                   if    self.tags[i] == "/OpenAction" or self.tags[i] == "/Action": 
                         self.objStats[key]['Parse'] = False
                         self.objStats[key]['Type'].append('OpenAction')
                          #print "parsing ---->",key
                         if not self.get_Javascript(key):
                                 #print "redir ---->",key
                                self.__handle_redir(key)
                         self.objStats[key]['Parse'] = True

 
                   elif  self.tags[i] == "/Annot": 
                         self.objStats[key]['Parse'] = False
                         self.objStats[key]['Type'].append('Annot')
                         if not self.get_Javascript(key):
                                self.__handle_redir(key)
                         self.objStats[key]['Parse'] = True
 

                   elif  self.tags[i] == "/XFA": 
                         self.objStats[key]['Parse'] = False
                         self.objStats[key]['Type'].append('XFA')
                         if not self.get_Javascript(key):
                                self.__handle_redir(key)
                         self.objStats[key]['Parse'] = True

                   
                   elif  self.tags[i] == "/Page":
                         if re.search('/Contents',self.objects[key]):
 
                            self.objStats[key]['Parse'] = False
                            self.objStats[key]['Type'].append('Page')
                            if not self.get_Javascript(key):
                                 self.__handle_redir(key)
                            self.objStats[key]['Parse'] = True



 
                   elif  self.tags[i] == "/Acroform": 
                         self.objStats[key]['Parse'] = False
                         self.objStats[key]['Type'].append('Acroform')
                         if not self.get_Javascript(key):
                                self.__handle_redir(key)
                         self.objStats[key]['Parse'] = True
                   
                   elif  self.tags[i] == "/JS":
                         self.objStats[key]['Parse'] = False
                         self.objStats[key]['Type'].append('JavaScript')
                         if not self.get_Javascript(key):
                                self.__handle_redir(key)
                         self.objStats[key]['Parse'] = True
    
                   elif  self.tags[i] == "/EmbeddedFile":
                         self.objStats[key]['Parse'] = False
                         self.objStats[key]['Type'].append('EmbeddedFile')
                         if not self.get_Javascript(key):
                                self.__handle_redir(key)
                         self.objStats[key]['Parse'] = True

 
                   elif  self.tags[i] == "/Filter":
                         self.objStats[key]['Parse'] = False
                         self.objStats[key]['Type'].append('Filter')
                         if not self.get_Javascript(key):
                                   self.__handle_redir(key)
                                   self.jsbuff = self.decompress_stream(key)
                                   if self.jsbuff:
                                      self.get_jsStat(key,self.jsbuff)
                                      self.get_Stream_Info(self.jsbuff) 
                         self.objStats[key]['Parse'] = True
                 
                   else: 
                         # Define default action here

                         #self.get_Javascript(key)
                         #self.objStats[key]['Parse'] = True
                         pass
            else:
                  
                 self.objStats[key]['Type_unknown'] = True  
                 if self._isJS_inStream(key): 
                         self.get_jsStat(key)
                 if self._is_File(key): self.objStats[key]['Embedded_File'] = True 
                 self.handle_evasion(key,self.objbuff) 

         return self.objStats    


def test_dir(folder):
    ## walk the folder and test each file 
    count = 0 
    clean = 0 
    mal   = 0
    sus   = 0 
    files = [] 
    for File in os.listdir(folder):
        print "SCANNING FILE",File
        print "+" * 30
        File = folder + "/" + File
        score = process_file(File)
        """
        pdf = file(File,"rb").read()
        objs = PDFobjects(pdf)
        objects = objs.pdf_objs() 
        score = score_pdf.gen_pdf_file_score(objs.parse_objs())
        """ 
        print "Score of file is -->",score
        
        if score == 0:
           clean+=1
           files.append(File) 
        elif score > 0 and score < 3:
           sus += 1
        else:
           mal +=1
           #files.append(File) 
        count += 1
        score = 0  
    print files
    print "Sus files %s, mal files %s, clean files %s, total files %s" %(sus,mal,clean,count) 
        #if count > 100: break
    # #print count
    sys.exit(0)





def process_file(pdf):
    filename = pdf
    files = []
    pdf = file(pdf,"rb").read()
    objs = PDFobjects(pdf)
  
    objects = objs.pdf_objs() 
    stats = objs.parse_objs()
    score = score_pdf.gen_pdf_file_score(stats) 
    print score
    return score


def prog():

     print "This is python parser \n"




def call(file):

    test_file(file)  









def main():

    parser = OptionParser(usage="usage: %prog [options] filename",
                          version="%prog 1.0")
    parser.add_option('-f', '--file',
                      type='choice',
                      action='store',
                      dest='filename',
                      choices=['file', 'dir'],
                      default='file',
                      help='provide file or dir name',)
    (options, args) = parser.parse_args()
    
    if len(args) == 0:
        parser.error("wrong number of arguments")


    if options.filename == 'dir':
       test_dir(args[0])
    
    if options.filename == 'file':
       process_file(args[0]) 
      
    else:
        parser.error("wrong number of arguments")



if __name__ == "__main__":
    main()
    #call(sys.argv[1])

